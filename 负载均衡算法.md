# 负载均衡算法

* 随机算法

* 加权随机算法

* 轮询算法

* 加权轮询算法

* 平滑加权轮询算法

* 一致性哈希算法

* 最小活跃数算法

  

## 加权随机算法

背景： A、B、C三台服务器，权重分别为：[2, 3, 5]

实现思路：

1. 随机产生一个随机数offset，范围是0到ABC权重之和
2. 循环权重列表，如果权重大于offset，则选用该服务，否则将offset减去当前权重，再进入下次循环

0---2------3--------------5-------->



## 加权轮询算法

背景： A、B、C三台服务器，权重分别为：[2, 3, 5]

实现思路：

1. 产生一个自增的数字offset，offset = offset % ABC权重之和
2. 循环权重列表，如果权重大于offset，则选用该服务，否则将offset减去当前权重，再进入下次循环



## 平滑加权轮询算法

背景： A、B、C三台服务器，权重分别为：[5, 1, 1]

服务器属性：ip、weight（固定）、currentWeigth（动态）

初始值currentWeight ： [0, 0, 0]

实现思路：		

| currentWeight += weight | max(currentWeight) | max(currentWeight) -sum(weight) | return |
| :---------------------- | ------------------ | ------------------------------- | ------ |
| 5, 1, 1                 | 5                  | -2, 1, 1                        | A      |
| 3, 2, 2                 | 3                  | -4, 2, 2                        | A      |
| 1, 3, 3                 | 3                  | 1, -4, 3                        | B      |
| 6, -3, 4                | 6                  | -1, -3, 4                       | A      |

## 一致性哈希算法

背景： A、B、C三台服务器

虚拟一个hash环，如图：

![1561174098106](.\负载均衡算法-虚拟hash环.png)

优点：当一个节点挂了，可以把这个节点的流量均匀的分布到其它节点上

实现思路：

1. 使用TreeMap实现一个虚拟节点的hash容器
2. 当一个ip来了，调用hash算法，得到hash值
3. 使用得到的hash值，去TreeMap获取大于该hash的第一个节点



## 最小活跃数算法

活跃数：每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。

实现思路：

	1. 在所有服务列表中找到活跃数最小的所有的服务列表

 	2. 采用随机算法从最小服务列表中选出一个服务，如果每个服务有权重，可以再采取以上的加权随机算法等选举服务