# juc同步框架

> 原文：《The java.util.concurrent Synchronizer Framework》
>
> 参考：https://www.cnblogs.com/dennyzhangdd/p/7218510.html

## 摘要

​        在J2SE 1.5的java.util.concurrent包（下称j.u.c包）中，大部分的同步器（例如锁，屏障等等）都是基于AbstractQueuedSynchronizer类（下称AQS类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞、解除阻塞以及队列提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。

## 1. 介绍

通过JCP的JSR166规范，Java的1.5版本引入了j.u.c包，这个包提供了一系列支持中等程度并发的类。

## 2. 需求

### 2.1 方法功能

　　同步器（指AQS及其子类）提供了两种类型的方法，至少有一个acquire方法用于阻塞调用这个方法的线程，直到同步状态（aqs中的state字段）允许它继续运行。至少有一个release方法，该方法会修改同步状态，然后可能会将一个或者多个阻塞的线程唤醒。

　　并发包下的各个同步器并没有定义一个统一的api。有些是通过普通接口定义的（如：Lock），但是其它的有同步器有不同的接口定义。因此acquire、release操作在不同的类中有不同的名称。例如，Lock.lock、Semaphore.acquire、CountDownLatch.await和FutureTask.get都关联了acquire操作。但是，J.U.C为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：

	* 阻塞和非阻塞（例如tryLock）同步
	* 可选的超时时间设置，让应用可以放弃等待
	* 可通过中断实现任务的取消，通常有两个方法，一个的acquire操作可以取消，另一个的acquire操作不能取消

　　同步器的实现根据其是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的的实现只维护独占状态，但是像计数信号量（counting semaphores）可能会允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。

　　j.u.c包里还定义了Condition接口，用于支持监控形式的await/signal操作，这些操作与独占模式的Lock类有关，且Condition的实现天生就和与其关联的Lock类紧密相关。

### 2.2 性能目标



## 3. 设计和实现

### 3.3 队列

　　这个框架的核心就是维护了一个阻塞线程的队列，是一个先进先出FIFO的队列。但是这个框架并不支持基于优先级的同步。

　　到目前为止，这一点几乎没有争论，同步队列的数据结构的的最佳选择是非阻塞的并且不会使用底层锁来构造。其中主要有两个选择：一个是Mellor-Crummey和Scott锁（MCS锁）[[9\]](http://ifeve.com/aqs-2/#r9)的变体，另一个是Craig，Landin和Hagersten锁（CLH锁）[[5\]](http://ifeve.com/aqs-2/#r5)[[8\]](http://ifeve.com/aqs-2/#r8)[[10\]](http://ifeve.com/aqs-2/#r10)的变体。一直以来，CLH锁仅被用于自旋锁。但是，在这个框架中，CLH锁显然比MCS锁更合适。因为它更容易实现取消和超时处理，所以我们选择CLH基础框架。但是最终的设计已经与原来的CLH锁有较大的出入，因此下文将对此做出解释。

　　CLH队列实际上并不那么像队列，因为它的入队和出队操作都与它作为锁的用途紧密相关。它是一个链表队列，通过两个字段`head`和`tail`来存取，这两个字段是可原子更新的，两者在初始化时都指向了一个空节点。

![](.\image\CLHNode.png)

一个新节点，node的原子入队操作：

```java
do{
	pred = tail;
}while(!tail.compareAndSet(pred, node))
```

每一个锁的释放状态都存储在其前驱节点中，因此，自旋锁的“自旋”操作就如下：

```java
while(pred.status != RELEASED);
```

自旋后的出队操作只需将head字段指向刚刚得到锁的节点：

```java
head = node;
```



　　第二个改动点事在每个节点中保存的状态是用于控制阻塞的，而不是控制自旋。在同步框架中，通过aquire方法入队列的线程只有在它调用定义在子类中的tryAcquire通过之后才会返回。

## 4. 用法



## 5. 性能



## 6. 总结



## 7. 鸣谢



## 8. 参考文献







