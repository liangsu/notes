# juc同步框架

> 原文：《The java.util.concurrent Synchronizer Framework》
>
> 参考：https://www.cnblogs.com/dennyzhangdd/p/7218510.html

## 摘要

​        在J2SE 1.5的java.util.concurrent包（下称j.u.c包）中，大部分的同步器（例如锁，屏障等等）都是基于AbstractQueuedSynchronizer类（下称AQS类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞、解除阻塞以及队列提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。

## 1. 介绍

通过JCP的JSR166规范，Java的1.5版本引入了j.u.c包，这个包提供了一系列支持中等程度并发的类。

## 2. 需求

### 2.1 方法功能

　　同步器（指AQS及其子类）提供了两种类型的方法，至少有一个acquire方法用于阻塞调用这个方法的线程，直到同步状态（aqs中的state字段）允许它继续运行。至少有一个release方法，该方法会修改同步状态，然后可能会将一个或者多个阻塞的线程唤醒。

　　并发包下的各个同步器并没有定义一个统一的api。有些是通过普通接口定义的（如：Lock），但是其它的有同步器有不同的接口定义。因此acquire、release操作在不同的类中有不同的名称。例如，Lock.lock、Semaphore.acquire、CountDownLatch.await和FutureTask.get都关联了acquire操作。但是，J.U.C为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：

	* 阻塞和非阻塞（例如tryLock）同步
	* 可选的超时时间设置，让应用可以放弃等待
	* 可通过中断实现任务的取消，通常有两个方法，一个的acquire操作可以取消，另一个的acquire操作不能取消

　　同步器的实现根据其是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的的实现只维护独占状态，但是像计数信号量（counting semaphores）可能会允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。

　　j.u.c包里还定义了Condition接口，用于支持监控形式的await/signal操作，这些操作与独占模式的Lock类有关，且Condition的实现天生就和与其关联的Lock类紧密相关。

### 2.2 性能目标



## 3. 设计和实现

### 3.3 队列

　　这个框架的核心就是维护了一个阻塞线程的队列，是一个先进先出FIFO的队列。但是这个框架并不支持基于优先级的同步。

​		

## 4. 用法



## 5. 性能



## 6. 总结



## 7. 鸣谢



## 8. 参考文献







