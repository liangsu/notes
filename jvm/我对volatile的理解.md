# 我对volatile的理解

首先通过问问题的方式，一层一层的剖析volatile变量。

问题1：加了volatile和没有加volatile的变量，会有什么不同，网上都说volatile能够保证可见性，有序性。

## 1. 对可见性的理解

1. cpu级别的mesi协议针对的应该是不管你加没加volatile的变量共享的问题，都能够使用到mesi协议
2. cpu保证的可见性是，高速缓存与主内存的数据一致性，从而保证了可见性。但cpu并没有保证寄存器与主内存的数据的一致性，所以在2个线程同时对一个变量（不管是否是volitale变量）执行+1百万次，最后结果小于2百万
3. 如果这么说来，不管是不是volatile变量，cpu都能保证它的可见性。只是volatile还多了一层语义，就是保证有序性。所以可见性不是由volatile保证
4. volatile的伪代码理解

```
volatile a = false;
线程1

	初始化配置文件
	a = true;
	
线程2
	if(a){
		读取配置文件中的值
	}
```

* 如果变量a不是volatile，那么有可能先执行【a = true】，然后执行【初始化配置文件】，这时线程2如果判断到a等于true，去执行【读取配置文件中的值】就会出错。
* 如果变量a是volatile，那么【初始化配置文件】一定在【a = true】之前执行，这时线程2如果判断到a等于true，去执行【读取配置文件中的值】绝对不会保存。
* 所以：
  volatile能够保证：如果a操作是对volatile变量的写操作，b操作是对volatile变量的读操作，
  如果a操作先行发生于b操作，那么a操作之前的操作先行发生于b操作之后的操作（这也是happens bofore中的一条规则）

5. 结论：相比较普通变量而言，volatile保证的是有序性

## 2. volatile是怎么保证有序性的

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

## 