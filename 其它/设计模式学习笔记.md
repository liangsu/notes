# 设计模式学习笔记

### 门面模式：
* 提供一个访问接口，不用管内部实现
* 在servlet中，屏蔽掉一些不希望暴露的

### 观察者模式：
* 本质：触发联动
* 在swing中，大多的点击事件都是采用观察者模式，一般命名为Listener，在通常情况下都会有一个listener去调用其它的所有的listener
* 实现了目标和观察者之间的解耦
* 有推、拉两种模式
* 观察者模式经常和中介者模式、状态模式结合使用

### 适配器模式：
* 其目的是为了更大程度的复用代码，自我感觉是在版本升级的过程中应该用得比较多
* 在产品升级过程中，为了不改变原有接口方式的情况下，同时兼容现有的新接口的调用方式，这时就可以使用一个适配器来适配原有接口的调用方式
* 如果在一个项目中，出现了很多的适配器这将是一场灾难，使代码的结构非常的复杂
* 适配器有：适配对象、适配类两种情况。通常使用适配对象，更主要的是具体情况具体分析

### 单例模式：
* 分为：饿汉式、懒汉式，由于考虑线程安全的问题，饿汉式有多种实现方式
* 单例的目的是为了只创建一个实例，其实我们也可以控制到只创建n个实例。
* 如果加载单例类的类加载器不是同一个，那么也不能保证单例

### 工厂方法模式：
* 本质：延迟到子类来选择实现；
* 与IOC/DI思想高度类似，控制反转、依赖注入是同一事物的不同角度的描述；
* 工厂方法的特例是简单工厂；
* 工厂方法的使用分为两种，一种是使用creator类对象，一种是使用creator类创建的对象；
* 工厂方法的使用场景适用于，知道要做些什么，但又不知道具体的实现；
* 体现了设计原则：高层组件不依赖于低层组件，不管高层组件还是低层组件都应该依赖于抽象。

### 抽象工厂模式：
* 本质：选择产品簇的实现
* 优点：分离接口和实现、使得切换产品簇变得容易
* 缺点：不太容易增加新产品；容易造成类层次复杂，在面对多个层次的选择的时候，抽象工厂的实现也需要分出层次来，每一层负责一种选择，也就是屏蔽一种变化
* 使用场景：一个系统只指导产品的接口，不关心实现的时候；一个系统由多个产品系列中的一个来配置的时候，换句话说，可以动态切换产品簇的时候；强调一系列相关产品的接口，以便联合使用它们的时候


### 生成器模式：
* 本质：分离整体构建算法和部件构造

### 原型模式：
* 本质： 克隆生成对象
* jdk中有默认有一种实现方式，实现Cloneable接口
* 实际开发中的案例：
* 如果在开发中仅仅是为了一个业务而在类上划一刀，添加一个方法，使用克隆模式，这样好不好？

### 中介者模式：
* 本质：封装交互
* 例子：cpu、光驱、显卡之间的交互都交给中介者

### 代理模式：
* 本质：控制对象访问
* 代理的分类：虚代理、远程代理、copy-on-write代理、保护代理、Cache代理、防火墙代理、智能代理

### 迭代器模式：
* 本质：控制访问聚合对象中的元素
* 迭代器模式可以让你访问一个聚合对象的内容，而无需暴露该聚合对象的内部表示
 
### 组合模式
* 本质：统一组合对象和叶子对象

### 模板方法
* 本质：固定算法骨架
* 典型案例：Collections.sort(List, Comparator);
* 优点：实现代码的复用
* 缺点：算法骨架不容易升级

### 策略模式
* 本质：分离算法，选择实现
* 案例：针对普通用户、vip用户使用不同的打折策略

### 状态模式
* 本质： 根据状态来分离和选择行为

### 备忘录模式
* 本质：保存和回复内部状态



### 责任链
* 本质：分离职责，动态组合
* 责任链的特例是功能链
* 责任链与装饰器模式的区别：多个装饰器之间会有一定的联系，而责任链的各个职责对象实现的功能，相互之间没有关联的


### 命令模式
* 本质：封装请求
* 优点： 更松散的耦合、更动态化的控制（参数化、队列化、日志化）、很自然的符合命令、更好的扩展性
* 应用： 撤销、重做

### 装饰器模式
* 本质： 动态组合
* 在设计时，各个装饰器之间最好是完全独立的功能，不要有依赖，这样在进行装饰组合的时候，才没有先后顺序的限制，也就是先装饰谁和后装饰谁都应该是一样的，否则会大大降低装饰器组合的灵活性
* JDK中的IO中就很明显的使用了装饰器模式，所有继承自FilterOutputStream的都是装饰器，输入流类似
* 在不影响其它对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰器模式，这几乎就是装饰器的主要功能
* 如果不适合使用子类来进行扩展的时候，可以考虑使用装饰模式
* 装饰模式与组合模式的区别：这两个模式有相似之处，都设计到对象的递归调用，从某种角度讲可以把装饰看做是只有一个组件的组合。但他们的目的完全不一样，装饰模式是要动态的给对象增加功能，而组合模式是想要管理组合对象和叶子对象，为他们提供一个一致的操作接口给客户端，方便客户端使用


### 享元模式
* 本质：分离与共享
* 享元模式的升级版是实例池，它的两个基本难点，一个是动态控制实例数量，另一个是动态分配实例来提供给外部使用。这些都需要算法来做保证的。
* 享元对象的管理，可以引入计数、垃圾清除等
