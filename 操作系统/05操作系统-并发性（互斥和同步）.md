# 操作系统—并发性（互斥和同步）

> 

## 1.并发的原理

1. 并发发生的情况：
	* 资源共享：内存
	* 互斥访问：设备（打印机）
	
2. 进程的交互：
	* 进程之间不知道对方的存在
	* 进程间知道对方的存在（如：共享对象）
	* 进程直接知道对方的存在
	
## 2.互斥：硬件的支持

1. 中断禁用
```c
while(true){
	/* 禁用中断 */
	/* 临界区 */
	/* 启用中断 */
	/* 其余代码 */
}
```

缺点:

	* 不能用于多处理器体系结构
	* 处理器被限制得只能交替执行程序



2. 专用机器指令

   * compare & swap
   * exchange

```c
int bolt = 1;

void p(int i){
	while(true){
        while(compare_and_swap(bolt, 0, 1) == 1)
            /* 不做任何事情 */
        /* 临界区 */
        bolt = 0;
        /* 其余代码 */
    }
}
```

特点：

	* 适用于单处理器或共享内存的多处理器的任意数量的进程
	* 简单易于证明
	* 可用于支持多个临界区，每个临界区可以用它自己的变量定义

缺点：

* 使用了忙等待（自旋等待）：会继续消耗处理器时间
* 可能饥饿
* 可能死锁：在处理器情况下，进程p1执行compare&swap后，然后p1被中断并把处理器让给具有更高优先级的p2，p2试图使用资源，它会进入忙等待循环，但是由于p1优先级比p2的优先级低，因此p1永远不会被调度执行

## 3.信号量

> 没有获取到资源的会进入到阻塞队列。
>
> 使用信号量可以实现：互斥锁、共享锁、读写锁（个人理解）
>
> 可以用于限制一次最多有几个同时执行，如果是一个就可以当做是互斥锁

1. 信号量简述：
   * 一个信号量可以初始化为非负数
   * semWait操作使信号量减1。若值变为负数，则阻塞执行semWait的进程，否则继续执行
   * semSignal操作使信号量加1。若值小于等于0，则被semWait操作的阻塞的进程解除阻塞

```c
struct{
	int count;
    QueueType queue; // 等待的进程队列
}
```

## 4.管程

> 定义：管程由一个或多个过程、一个初始化序列和局部数据组成的软件模块

1. 特点：
   * 1
2. 