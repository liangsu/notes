# 操作系统—并发（饥饿和死锁）

> 

## 1.死锁的原理

1. 定义：一组相互竞争系统资源或进行通信的进程间的“永久”阻塞。
2. 资源分类：
   * 可重用资源：指一次仅供一个进程安全使用且不因使用资源而耗尽的资源，如：处理器、I/O通道、内存和外存、设备，以及诸如文件、数据库、信号量之类的数据结构
   * 可消耗资源：指可被创建（生产）和销毁（消耗）的资源。如：中断、信号、消息、I/O缓冲信息
3. 资源分配图：

![](.\601资源分配图.png)

4. 死锁的条件（前三个是必要条件，第4个充分条件）：
   * 互斥：一次只有一个进程可以使用一个资源
   * 占有且等待：当一个进程等待其它进程时，继续占有已分配的资源
   * 不可抢占：不能强行抢占进程已占有的资源
   * 循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的资源

5. 处理死锁的3种方法：
   * 采用某种策略消除条件1~4中的某个条件出现来【预防】死锁
   * 基于资源分配的当前状态做动态选择来【避免】死锁
   * 试图【检测】死锁（满足条件1~4）的存在并从死锁中恢复

## 2.死锁的预防

1. 简介：死锁预防分为两类。一类是间接预防死锁，防止前面三个必要条件中的任何一个条件发生。另一类是直接死锁的的预防，即防止循环等待的发生
2. 互斥：这个条件不可能禁止
3. 占有且等待：

## 3.死锁的避免

### 3.1进程启动拒绝

![](.\602资源分配矩阵.png)

### 3.2资源分配拒绝

1. 资源分配拒绝又称：银行家算法

2. 系统状态：当前给进程分配资源的情况

3. 安全状态：至少有一个资源分配序列不会导致死锁。满足C(ij) - A(ij) <= V(j)

4. 非安全状态：非安全的一种状态

5. 进程请求一个资源时，判断分配后是否满足安全状态，如果满足则分配，不满足则不分配

6. 小结：死锁避免策略并不能确切地预测死锁，它仅是预料死锁的可能性并确保永远不可能出现这种可能性

![](.\603安全状态的确定.png)



7. 优点：
   * 无须死锁预防中的抢占和回滚进程，且与死锁预防相比限制较少

8. 限制：
   * 必须事先声明每个进程请求的最大资源
   * 所讨论的进程必须是无关的，即它们的执行顺序必须没有任何同步要求的限制
   * 分配的资源数量必须是固定的
   * 在占有资源时，进程不能退出


## 4.死锁检测

> 简介：只要有可能，就会给进程分配其所请求的的资源。操作系统周期性地执行一个算法来检测循环等待条件

### 4.1死锁检测算法

1. 前提：

   * Allocation矩阵
   * Available向量

   * 请求矩阵：Q(ij)表示进程i请求j类资源的数量
   * 最初所有的进程是未标记的

2. 执行步骤：

   * 标记

3. 上述执行完成，存在未标记的进程就是存在死锁的进程

### 4.2恢复



