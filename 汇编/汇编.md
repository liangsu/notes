## 1.基础知识
1. 地址总线
	* 寻址范围：2^n，n为总线宽度
	* 地址加法器：物理地址 = 段地址 * n + 偏移地址 = 基础地址 + 偏移地址
2. 数据总线
	* 数据总线的宽度决定cpu和外界数据传送的速度
3. 控制总线
	* 控制总线是一些不同控制线的集合，总线的宽度决定了cpu对外部器件的控制能力

内存地址空间：
	* 把显卡、内存条、硬盘、网卡等总的看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是内存地址空间，如：
		* 地址0-7FFFH的32k空间为主随机存储器的地址空间
		* 地址8000H-9FFFH的8k空间为显存的地址空间
		* 地址A000H-FFFFH的24k空间为各个ROM的地址空间
	* 不同计算机系统的内存地址空间不同

每一种cpu都有自己的汇编指令集


## 2.寄存器
通用寄存器：ax、bx、cx、dx
段寄存器： cs、ds、ss、es
指令寄存器：cs（存放段地址）、ip（指令偏移）
栈寄存器：ss、sp
内存访问寄存器ds：用于将ds指向的内存地址的值当做段地址，加上偏移量指向的内存的值，赋值给某一个寄存器
cx寄存器：可以用来存储loop指令循环的次数

[bx]： 将寄存器bx中的内容，当做ds寄存器的偏移量


段寄存器：
	* 送入地址加法器合成物理地址
	* 段寄存器有：cs、ds、ss、es
	* 将内存中的
	
cs、ip寄存器：
	* 指示了cpu要读取指令的地址
	* 同时修改cs、ip：	jmp 2AE3:3
	* 只修改ip寄存器的值： jmp ax
	* 不能使用：mov cs bx
	
## 3.寄存器（内存访问）

1. ds和[address]
	* 内存地址有段地址和偏移地址组成，ds寄存器指示了内存单元的段地址
	
	* 案例：
		* 读取10000H单元的内容
		```
			mov bx 1000H
			mov ds, bx
			mov al, [0]
		```
		* 向10000H单元写数据
		```
			mov bx, 1000H
			mov ds, bx
			mov [0], al
		```
	
2. 栈		
	* 将内存中的一段内存作为栈，具有特殊的访问方式
	* 8086cpu使用ss、sp寄存器指向栈顶的地址，并提供push、pop指令实现入栈、出栈。
	* 8086cpu提供的入栈、出栈会出现越界的问题

数据段、代码段、栈段

3. mov、add、sub指令
```
mov 寄存器, 数据
mov 寄存器, 寄存器
mov 寄存器, 内存单元
mov 内存单元, 寄存器
mov 段寄存器， 寄存器

add/sub 寄存器, 数据
add/sub 寄存器, 寄存器
add/sub 寄存器, 内存单元
add/sub 内存单元, 寄存器
```

## 5.loop和[bx]指令

1. 段前缀：
	* 将内存中的值传送到寄存器可以显示指定段寄存器，而不是使用默认的ds寄存器，如：
		```
			mov ax, cs:[0]
			;或者
			mov ax, es:[bx]
			;或者
			mov ax, [0] ; 段地址在ds中
		```
		

在汇编程序中，数据不能以字母开头：
```
 mov ax, 0ffffh
 ;不能写成
 mov ax ffffh
```

## 6.包含多个段的程序

例子：
```
assume cs:code, ds:data, ss:stack 	;声明三个段
data segment ; 数据段
	dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h
data ends
stack segment ; 栈段
	dw 0, 0, 0, 0, 0, 0, 0, 0
		; 使用dw定义8个字型数据，在程序加载的时候将取得8个字的内存空间
		; 存放这8个数字，在后面的程序中，将这段空间当做段使用
stack ends		
code segment ; 代码段
	start:  mov ax, stack
			mov ss, ax
			mov sp, 16 			; 指定栈寄存器ss:sp的值
			
			mov ax, data
			mov ds, ax			; 设置数据段
			
			mov bx, 0
			mov cx, 8
		s:  push ds:[bx]
			add bx, 2
			loop s 			; 入栈
			
			mov bx, 0
			mov cx, 8
		s0: pop ds:[bx]
			add bx, 2
			loop s0 		; 出栈
						
			mov ax,4c00h
			int 21h
code ends
end start ; 程序的入口
```

## 7.更灵活的定位内存地址的方法

1. and和or指令：
	
* 按位与、按位或
	
2. ascii码
	* 占用一个字节，可以使用db定义
	* 大小写转换：大写字母与小写字母的差别是二进制编码的第6位是否1，即：2^5 = 32

3. [bx+idata]
	
	* 更灵活的定位内存单元，如：mov ax, [bx + 200]
	* 含义：将内存单元的内容送入ax，这个内存单元的偏移地址是bx+idata，段地址ds
	* 数学化描述： (ax) = ((ds)*16 + (bx) + 200);
	* 用处：进行数组的处理
	
4. si和di寄存器
	* si和di和bx功能相近，但si和di不能分成两个8位寄存器来使用，下面几句功能一样
	```asm
	mov bx, 0
	mov ax, [bx + 123]
	; 和
	mov si, 0
	mov ax, [si + 123]
	;和
	mov di, 0
	mov ax, [di + 123]
	```
	
5. [bx+si]和[bx+di]	
	* [bx+si]和[bx+di]含义一样，如： `mov ax, [bx + si]` 
	* 含义：将内存单元的内容送入ax，这个内存单元的偏移地址是bx+si，段地址ds
	* 数学化描述： (ax) = ((ds)*16 + (bx) + (si));
	* 也可写成： `mov ax, [bx][si]`

6. [bx+si+idata]和[bx+di+idata]
	* 数学化描述： (ax) = ((ds)*16 + (bx) + (si) + idata);
	* 下面写法实现功能一样
	```assembly
		mov ax, [bx + si + 200]
		mov ax, [200 + bx + si]
		mov ax, 200[bx][si]
		mov ax, [bx].200[si]
		mov ax, [bx][si].200
	```
	
## 8.数据处理的基本问题

1. bx、si、di、bp
	* 只有这4个寄存器可以用在[...]中来进行内存单元寻址
	* 在[...]中，这四个寄存器可以单个出现，或者使用以下4种组合
		* bx + si， 默认段地址在ds中
		* bx + di， 默认段地址在ds中
		* bp + si， 默认段地址在ss中
		* bp + di， 默认段地址在ss中

2. 指令处理的数据在什么地方：
	* 内存， mov ax, [0]
	* cpu内部，寄存器， mov ax, bx
	* cpu内部，指令缓冲器， mov ax, 1

3. 汇编语言中数据位置的表达
	* 立即数idata
	* 寄存器
	* 段地址（SA）和偏移地址（EA）

4. 寻址方式
	4.1 [idata]： 直接寻址
	4.2 [bx/si/di/bp] 寄存器间接寻址
	4.3 [bx + idata] 寄存器相对寻址
	4.4 [bx + si] 基址变址寻址
	4.5 [bx + si + idata] 相对基址变址寻址
	
5. 指令处理的数据有多长
	5.1 通过寄存器名指明要处理的数据的尺寸，如：
	```
		mov ax, 1
		mov ax, ds:[0]
		; 或者
		mov al, 1
		mov al, ds:[0]
	```
	5.2 在没有寄存器名存在的情况下，用操作符 X ptr指明内存单元的长度，X在汇编指令中可以为word和byte
	```
		mov word ptr ds:[0], 1
		inc word ptr [bx]
		; 或者
		mov byte ptr ds:[0], 1
		inc byte ptr [bx]
	```
	5.3 push只进行字操作
	
6. div指令
	* 除数8位： AX / [reg或者内存单元] = 商:al  余数：ah
	* 除数16位： (DX AX) / [reg或者内存单元] = 商:AX  余数：DX
	* 例子1：
		```
			div byte ptr ds:[0]
		```
		* 含义：(al) = (ax) / ((ds)*16 + 0) 的商
				(ah) = (ax) / ((ds)*16 + 0) 的余数
	* 例子2：
		```
			div word ptr es:[0]
		```
		* 含义：(ax) = ((dx)*10000H + (ax)) / ((es)*16 + 0) 的商
				(dx) = ((dx)*10000H + (ax)) / ((es)*16 + 0) 的余数			
	
7. 伪指令dd
	
* dd用来定义dword(double word，双字)型数据，占2个字，4个字节
	
8. dup指令
	* dup是一个操作符，在汇编语言中同dd、dw、db等一样，也是有编译器识别处理的符号
	* 和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复
	* 例如：
	```
		db 3 dup(0)		;相当于： db 0, 0, 0
		db 3 dup(0, 1, 2)		;相当于： db 0, 1, 2, 0, 1, 2, 0, 1, 2
	```


## 9. 转移指令

1. 概念
	* 描述：可以修改ip或者同时修改cs、ip的指令统称为转移指令
	* 段内转移： 只修改ip
		* 段内短转移：ip修改范围 -128 ~ 127 
		* 段内近转移：ip修改范围 -32768 ~ 32767 
	* 段间转移： 同时修改cs、ip
	
	* 转移指令分为：
		* 无条件转移（如：jmp）
		* 条件转移指令
		* 循环指令（如：loop）
		* 过程
		* 中断
	
2. 操作符offset	
	* 是由编译器处理的符号，功能是取标号的偏移地址
	* 例子：
	```
		s: mov ax, offset s		; 取s在代码中的偏移地址
		s1: nop;
			nop;
	```
	* nop的机器猫占用一个字节

3. 依据位移进行转移的jmp指令 
		* “jmp short 标号” 功能： (ip) = (ip) +  8位位移
		* “jmp near ptr 标号” 功能： (ip) = (ip) + 16位位移

4. 转移的目的地址在指令中的jmp指令
		
	
	* “jmp far ptr 标号” 功能：(cs) = 标号所在段的短地址， (ip) = 标号在段中的偏移地址
	
5. 转移地址在寄存器中的jmp指令
		
	
	* “jmp 16位reg” 功能：(ip) = 16位reg
	
6. 转移地址在内存中的jmp指令
		* jmp word ptr 内存单元地址（段内转移），功能：(ip) = (内存单元地址)
		* jmp dword ptr 内存单元地址（段间转移），功能：(ip) = (内存单元地址)， (cs) = (内存单元地址 + 2)

7. jcxz指令
	* jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，对ip修改范围：-128~127
	* 指令格式： jcxz 标号
	* 功能表示：if((cx) == 0) jmp short 标号
	
8. loop指令
	* loop指循环指令，所有的循环指令都是短转移，对应的机器码中包含转移的位移，而不是目的地址。对ip修改范围：-128~127
	* 功能表示：if((cx) != 0) jmp short 标号
	
9. 根据位移进行转移的意义：
	
	* 方便了程序段在内存中的浮动装配


10. 屏幕
	* 屏幕显示的字符在b8000H
	* 25 * 80 指：25行80列
	* 内存分布：字符 + 属性
	* 颜色：
		```
			 7     6 5 4     3    2 1 0             
			BL     R G B     I    R G B
			闪烁   背景色  高亮   前景
		R: 红
		B：绿
		B：蓝
		```
		


9. 子程序的设计（个人看法）：
	stack  c1					; 存转移指令后的地址，方便恢复
	stack params      [2:a,b & rd][1:a]  ; 存调用传入的参数，返回结果的地址
	stack local args c1:		; 每个程序一个局部变量表，在转移的时候存下当前程序的状态信息
	stack local args c2:
	stack local args c3:
   
	mov ax, 0
	jmp c2
	c1: add ax, 2	
	
	c2: mov bx, 0
	add bx, 1
	jmp c3
	jmp c1
	
	c3: mov bx,3
		add bx,2
		jmp c2
	

## 10. CALL和RET指令
> call和ret指令都是转移指令，它们都修改ip，或者同时修改cs和ip

1. ret和retf
	* ret指令相当于：pop ip
	* retf指令相当于： pop ip、pop cs

2. cpu执行call指令时，进行以下两步操作
	* 将当前ip或者cs和ip压入栈中
	* 转移
	
3. call指令的语法：
	3.1 依据位移进行转移的call指令：call 标号
		* 相当于执行： push ip、 jmp near ptr 标号
		
	3.2 转移的目的地址在指令中的call指令：call far ptr 标号：
		* 实现的是段间转移，相当于执行
		* push cs
		* push ip
		* jmp far ptr 标号
	
	3.3 转移地址在内存中的call指令：“call word ptr 内存单元地址” 或者 “call dword ptr 内存单元地址”
		* push cs （后一条语句才会有）
		* push ip
		* jmp word ptr 内存单元地址
	
4. mul指令（乘法）
	* 两个数相乘，要么都是8位，要么都是16位
	* 8位相乘：(ax) = (al) * (8位reg或内存单元)
	* 16位相乘：(dx ax) = (ax) * (16位reg或内存单元)
	* 例子：
		```
			mul reg
			mul 内存单元
			
			mul byte ptr ds:[0]
			mul word ptr ds:[0]
		```

5. 寄存器冲突的问题，子程序结构：
	```
	子程序开始：子程序使用的寄存器入栈
				子程序的内容
				子程序使用的寄存器出栈
				返回（ret或者retf）
	```

## 11. 标志寄存器
> 作用：
>   * 用来存储相关指令的某些执行结果
>   * 用来为cpu执行相关指令提供行为依据
>   * 用来控制cpu的相关工作方式
>
> 注意：
>   * 有的指令的执行是影响标志寄存器的，如：add、sub、mul、div、inc、or、and等
>   * 有的则对标志寄存器没有影响，如：mov、push、pop等
>
>

| 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      | OF   | DF   | IF   | TF   | SF   | ZF   |      | AF   |      | PF   |      | CF   |

标志在debug中的位置：

| NV   | UP   | EI   | PL   | NZ   | NA   | PO   | NC   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| OF   | DF   |      | SF   | ZF   |      | PF   | CF   |

标志寄存器在debug中的表示：

| 标志 | 值为1的标记 | 值为0的标记 |
| ---- | ----------- | ----------- |
| of   | OV          | NV          |
| sf   | NG          | PL          |
| zf   | ZR          | NZ          |
| pf   | PE          | PO          |
| cf   | CY          | NC          |
| df   | DN          | UP          |



1. zf标志（zero flag）
	* flag的第6位（从0开始），零标志位
	* 记录相关指令执行后，其结果是否为0
	* 例子1：下面的语句执行后，zf=0
	```
		mov ax, 1
		sub ax, 1
	```

2. pf标志（parity flag）
	* flag的第2位，奇偶标志位
	* 记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数
	* 注意，不能使用pf判断是否是奇数、偶数
	
3. sf标志（symbol flag）
	* flag的第7位，符号标志位
	* 记录相关指令执行后，其结果是否为负。如果为负，sf=1；如果非负，sf=0

4. cf标志（carry flag）（错位没太懂）
	* flag的第0位，进位标志位
	* 在进行【无符号】数运算的时候，记录运算结果的最高有效位向更高位的进位值，或从更高位的错位值
	* inc和loop指令不影响cf标志位
	
5. of标志（overflow flag）
    * flag的第1位，溢出标志位
	* 在进行【有符号】数运算的时候，记录相关指令执行后，其结果是否发生溢出
	* 个人心得：在计算是否发生溢出的时候，都是将补码转化为真正的数字进行运算后得出的是否发生溢出，如：
	```
	     1111 0000     F0H    -16的补码
	     0111 1000     78H    120的补码
	0001 0110 1000     168H   最高位舍弃后，为104的补码
	```

6. adc指令
	* adc ax, bx 实现的功能是：(ax)=(ax)+(bx)+(cf)
	* 作用：对任意大的数据进行加法运算
	
7. sbb指令
	
	* sbb ax, bx 实现的功能是：(ax)=(ax)-(bx)-(cf)
	
8. cmp指令
	* cmp是比较指令，相当于减法指令，只是不保存结果。执行后会对标志寄存器产生影响
	* 分析cmp指令对标志寄存器的影响（无符号数）
		* 正向分析：
			* 如果(ax)=(bx)，则(ax)-(bx)=0，所以：zf=1
			* 如果(ax)≠(bx)，则(ax)-(bx)≠0，所以：zf=0
			* 如果(ax)<(bx)，则(ax)-(bx)将产生错位，所以：cf=1
			* 如果(ax)≥(bx)，则(ax)-(bx)不必借位，所以：cf=0
			* 如果(ax)>(bx)，则(ax)-(bx)既不必借位，也不可能为0，所以：cf=0，zf=0
			* 如果(ax)≤(bx)，则(ax)-(bx)既可能借位，也可能为0，所以：cf=1或者zf=1
		* 逆向分析：
			* zf=1，说明(ax)=(bx)
			* zf=0，说明(ax)≠(bx)
			* cf=1，说明(ax)<(bx)
			* cf=0，说明(ax)>=(bx)
			* cf=0且zf=0，说明(ax)>(bx)
			* cf=1或zf=1，说明(ax)<=(bx)
	* 分析cmp指令对标志寄存器的影响（有符号数）
		* 如果sf=1,of=0，逻辑结果的正负=实际结果的正负，(ah)<(bh)
		* 如果sf=1,of=1，逻辑结果的正负≠实际结果的正负，(ah)>(bh)
		* 如果sf=0,of=0，逻辑结果的正负=实际结果的正负，(ah)≥(bh)
		* 如果sf=0,of=1，逻辑结果的正负≠实际结果的正负，(ah)<(bh)

9. 检测比较结果的条件转移指令

| 指令 | 含义         | 检测的相关标志位 |
| ---- | ------------ | ---------------- |
| je   | 等于则转移   | zf=1             |
| jne  | 不等于则转移 | zf=0             |
| jb   | 低于则转移   | cf=1             |
| jnb  | 不低于则转移 | cf=0             |
| ja   | 高于则转移   | cf=0 且 zf=0     |
| jna  | 不高于则转移 | cf=1 或 zf=1     |

j: jump
e: equal
ne: not equal
b: below
nb: not below
a: above
na: not above

10. df标志和串传送指令
	* flag的第10位，方向标志位。在串处理指令中，控制每次操作后si、di的增减
	* cld指令，英文clear direction，设置df=0，每次操作后si、di递增
	* std指令，英文set direction，设置df=1，每次操作后si、di递减
	
	* 串传送指令：movsb、movsw，将ds:si指向的内存单元的值送入es:di
	* movsb功能描述：
		* ((es)*16+(di)) = ((ds)*16+(si))
		* 如果df=0，则：(si)=(si)+1，(di)=(di)+1
		
	* rep指令，根据cx的值，重复执行后面的串传送指令，汇编描述：
	```
	s: movsb
	   loop s
	```

## 12. 内中断

1. 内中断的产生
	* cpu内部有下列情况发生的时候，将产生中断信息
		* 除法错误，比如执行div指令产生除法溢出
		* 单步执行
		* 执行into指令
		* 执行int指令
	
	* 中断源：产生中断信息的事件，即中断信息的来源
	
	* 中断类型码
		* 字节型数据，可以表示256种中断信息来源
		* 中断类型码如下：
			* 除法错误：0
			* 单步执行：1
			* 执行into指令：4
			* 执行int指令，该指令格式int n，指令中的n为字节型立即数，是提供给cpu的中断类型码
		* 作用： 用来定位中断处理程序

2. 中断处理程序
	* 解释：用来处理中断信息的程序称为中断程序
	* cpu在收到中断信息的时候，根据中断类型码找到中断程序并执行
	
3. 中断向量表
	* 中断向量：中断处理程序的入口地址。占用4个字节，高地址存放段地址，低地址存放偏移地址
	* 中断向量表： 断处理程序的入口地址的列表
	
	* 存放位置：8086cpu中，内存地址0处。从0000:0000到0000:03ff的1024个单元中存放着中断向量表

4. 中断过程
	* 根据中断码，找到中断向量，并用它设置cs和ip的过程，是cpu硬件自动完成的。cpu硬件完成这个工作的就是【中断过程】
	* 中断过程中cpu自动执行的操作：
		* 取得中断类型码N
		* pushf
		* TF=0，IF=0
		* push cs
		* push ip
		* (ip)=(N*4)， (cs)=(N*4+2)

5. 中断处理程序和iret指令
	* 中断处理程序编写常规步骤：
		* 保存用到的寄存器
		* 处理中断
		* 恢复用到的寄存器
		* 用iret指令返回
	
	* iret指令的汇编描述：
	```
		pop ip
		pop cs
		popf
	```
	
6. 编写中断处理程序
	* 将中断程序安装到0:200开始的地方
	* 编写中断程序
	* 修改中断向量
	
11. 单步中断
	* 基本上，cpu在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断码为1
	* 单步中断的中断过程如下：
		* 获取中断类型码1
		* 标志寄存器入栈，设置TF=0，IF=0
		* CS、IP入栈
		* (ip)=(1*4)， (cs)=(1*4+2)

12. 响应中断的特殊情况：
	* 在执行完ss寄存器的传送数据后，即便发生中断，cpu也不会响应
	```
		mov ax, 1000
		mov ss, ax
		mov sp, 0
		mov ax, 10
	```

## 13. int指令

1. cpu执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下
	* 取中断类型码n
	* 标志寄存器入栈，设置TF=0，IF=0
	* CS、IP入栈
	* (ip)=(n*4)， (cs)=(n*4+2)
	
2. int指令的用途：
	* 编写供应用程序调用的中断例程

3. int指令的深入理解
	* int指令可以实现loop的功能、jmp near ptr的功能等
	
4. BIOS和DOS所提供的中断例程
	* 在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包含以下几部分内容
		* 硬件系统的检查和初始化程序
		* 外部中断和内部中断的中断例程
		* 用于对硬件设备进行I/O操作的中断例程
		* 其他和硬件系统相关的中断例程
	
	* 操作系统DOS也提供了中断例程

5. BIOS和DOS中断例程的安装过程
	* 开机后，cpu一加电，初始化(cs)=0FFFFH，(ip)=0，自动从FFFF:0单元开始执行程序。
		FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序
	* 初始化程序将建立BIOS所支持的中断向量
	* 硬件系统的检查和初始化完成后，调用int 19h 进行操作系统引导。
	* DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立中断向量
	
6. BIOS中断例程的应用
	* int 10h: 显示光标位置、在光标处显示字符串

7. DOS中断例程的应用
	* int 21h: 显示ds:dx处的字符串
	
## 14. 端口

> 在pc系统中，和cpu通过总线相连的芯片除各种存储器外，还有以下3种芯片：
>	* 各种接口卡（网卡、显卡）上的接口芯片，他们控制接口卡进行工作
>	* 主板上的接口芯片，cpu通过它们对外部设备进行访问
>	* 其它芯片，用来存储相关的系统信息，或进行相关的输入输出处理
>
> cpu直接读写下面3个地方的数据：
>   * cpu内部的寄存器
>   * 内存单元
>   * 端口

1. 端口的读写
	* 端口的读写只有2条：in和out，分别用于从端口读取数据和往端口写入数据
	* 在in和out指令中，只能使用al和ax来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax
	* 对0~255以内的端口进行读写：
	```
		in al, 20h	 	; 从20h端口读入一个字节
		out 20h, al		; 向20h端口写入一个字节
	```
	* 对256~65535的端口进行读写时，端口号放到dx中
	```
		mov dx, 3f8h
		in al, dx
		out dx, al
	```

2. CMOS RAM芯片
	* 包含一个时钟和一个有128个存储单元的RAM存储器
	* 该芯片靠电池供电
	* 128个字节的RAM中，内部时钟占用0~0dh单元来保存时间信息
	* 该芯片内部有两个端口，端口地址为70h和71h。
	* 70h地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取数据，或要写入其中的数据

3. shl和shr指令
	* shl是逻辑左移指令，它的功能为：
		* 将一个寄存器或内存单元中的数据向左移动
		* 将最后移除的一位写入CF中
		* 最低位用0补充
		* 如果移动位数大于1时，必须将移动位数放在cl中

4. CMOS RAM中存储的时间信息
	* 在CMOS RAM中，存放着当前的时间，年月日时分秒，这6个信息的长度都为1个字节，存放单元为：
	
	* 秒：0、分：2、时：4、日：7、月：8、年：9
	
	* BCD码：
	
	  | 十进制 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
	  | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
	  | 二进制 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |
	
	* 例子：数值26用BCD码表示：0010 0110
	
	* 疑问：一个字节的BCD码能表示的最大数值是： 1001 1001，即99。而一个无符号的一个字节能表示的最大值为2^8-1=255。明显比99大，为什么要用BCD码
	
	* BCD码值 + 30H = 十进制数对应的ASCII码
	
## 15. 外中断

1. 接口芯片和端口
	* 外设：  网卡----> 芯片 ----> 寄存器(被cpu当做端口访问) ----> 主板 -----> CPU

2. 外中断信息
	* CPU提供中断机制来及时处理外设的输入
		* 外设的输入到达，相关芯片将向CPU发出相关的中断信息
		
	* cpu的中断可以来自cpu内部，还有cpu外部
	
	* 在PC系统中，外中断一共有以下2类：
		* 可屏蔽中断
		* 不可屏蔽中断
		
	* 【可屏蔽中断】
		* 可屏蔽中断是CPU可以不用响应的中断。
		* cpu是否响应可屏蔽中断，要看标志寄存器IF的设置，IF=1，cpu执行完当前指令后响应中断，引发中断过程；IF=0，则不响应可屏蔽中断
		
		* 引发外中断的过程
			* 取中断类型码n（内中断来自cpu内部，外中断的通过数据总线传入CPU的）
			* 标志寄存器入栈，设置TF=0，IF=0
			* CS、IP入栈
			* (ip)=(n*4)， (cs)=(n*4+2)
		
		* 在中断过程中将IF设置为0，在进入中断处理程序后，禁止其他的可屏蔽中断
		* sti：设置IF=1，响应可屏蔽中断
		* cli: 设置IF=0，不响应可屏蔽中断
	
	* 【不可屏蔽中断】
		* 不可屏蔽中断是CPU必须响应的外中断
		* 中断类型码固定为：2
		* 中断过程：
			* 标志寄存器入栈，设置TF=0，IF=0
			* CS、IP入栈
			* (ip)=(8)， (cs)=(0AH)
		
		* 几乎所有由外设引发的外中断，都是可屏蔽中断
		
3. PC机键盘处理过程
	* 键盘按下产生一个扫描码，通码；放开产生一个扫描码，断码
	* 断码 = 通码 + 80H
	* 键盘处理中断例程是：int9中断

## 16. 直接定址表

1. 描述了单元长度的标号
	* 没有冒号":"的标号，同时描述了单元地址和单元长度

2. 在其它段中使用数据标号
	* 用法：首先声明段的类型，再使用的时候程序里面要先设置段地址
	* 可以把标号当做数据来定义
	```
	data segment
		a db 1, 2, 3, 4, 5, 6, 7, 8
		b dw 0
		c dw a, b 		; 相当于： c dw offset a, offset b
		d dd a, b 		; 相当于： c dw offset a, seg a, offset b, seg b
	data segment
	```
	* seg操作符，功能为取某一标号的段地址
	
## 17. 使用BIOS进行键盘输入和磁盘读写

1. int 9中断：
	* 功能：将键盘的输入写入键盘缓冲区
	
2. int 16中断：
	* 功能：从键盘缓冲区读取键盘的输入
	* 参数：(ah)=0
	* 结果：(ah)=扫描码，(al)=ASCII码

3. 3.5英寸软盘：
	* 2面 * 80磁道 * 18扇区 * 512字节 = 1440KB ≈ 1.44M
	* 面号、磁道号：从0开始编号；扇区： 从1开始编号

3. int 13h中断：
	* 读/写取扇区:
		* 传入参数：
			* (ah)=功能号，2：读取扇区，3：写扇区
			* (al)=读取的扇区数
			* (ch)=磁道号
			* (cl)=扇区号
			* (dh)=磁头号（对于软盘即面号，因为一个面用一个磁头读写）
			* (dl)=驱动器号，软驱从0开始，0：软驱A、1：软驱B；硬盘从80H开始，80H：硬盘C、81H：硬盘D
			* es:bx 指向接收从扇区读入（写出）的内存区
			
		* 返回结果：
			* 操作成功：(ah)=0, (al)=读入（写入）的扇区数
			* 操作失败：(ah)=出错代码
			

## debug用法：
* r命令，查看、改变cpu寄存器的内容

* d命令，查看内存中的内容
	* 如： d 76c:0  查看76c:0出的内存内容
	* 如： d ds:0
	* 如： d ds:0 16  查看76c:0出的内存内容，查看长度16
	
* e命令，改写内存中的内容

* u命令，将内存中的机器指令翻译成汇编指令

* t命令，执行一条机器指令
	* 如：t 5  执行5条指令
	
* a命令，以汇编指令的格式在内存中写入一条机器指令

* g命令，执行到某一行。如：g 0012

* p命令，将循环执行完成，在loop s的时候使用
	* int 21h，使用p命令执行
	* call、loop使用p命令执行可以直接指向完成

1. debug和汇编编译器masm对指令的不同处理：
	1.1 在debug中，将ds:0的数据送入ax，使用 `mov ax, [0]`，在汇编源程序中这段指令会被编译成`mov ax, 0`，
		在汇编中要实现这个功能可以使用如下方式：
		```
			mov bx, 0
			mov ax, [bx]
			;或者
			mov ax, ds:[0]
		```
		


## 编译、链接

1. 编译命令：masm
	* masm a;
	
2. 链接命名：link
 * link a;

3. 编译、链接脚本，m1.bat
```
@echo off
echo masm.....
masm %1;

echo link.......
link %1;
del %1.obj
```

   






​	
​	
​	
​	
​	
​	
​	
​	
​	

