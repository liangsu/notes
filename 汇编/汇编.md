## 1.基础知识
1. 地址总线
	* 寻址范围：2^n，n为总线宽度
	* 地址加法器：物理地址 = 段地址 * n + 偏移地址 = 基础地址 + 偏移地址
2. 数据总线
	* 数据总线的宽度决定cpu和外界数据传送的速度
3. 控制总线
	* 控制总线是一些不同控制线的集合，总线的宽度决定了cpu对外部器件的控制能力

内存地址空间：
	* 把显卡、内存条、硬盘、网卡等总的看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是内存地址空间，如：
		* 地址0-7FFFH的32k空间为主随机存储器的地址空间
		* 地址8000H-9FFFH的8k空间为显存的地址空间
		* 地址A000H-FFFFH的24k空间为各个ROM的地址空间
	* 不同计算机系统的内存地址空间不同

每一种cpu都有自己的汇编指令集



## 2.寄存器
通用寄存器：ax、bx、cx、dx
段寄存器： cs、ds、ss、es
指令寄存器：cs（存放段地址）、ip（指令偏移）
栈寄存器：ss、sp
内存访问寄存器ds：用于将ds指向的内存地址的值当做段地址，加上偏移量指向的内存的值，赋值给某一个寄存器
cx寄存器：可以用来存储loop指令循环的次数

[bx]： 将寄存器bx中的内容，当做ds寄存器的偏移量

	
段寄存器：
	* 送入地址加法器合成物理地址
	* 段寄存器有：cs、ds、ss、es
	* 将内存中的
	
cs、ip寄存器：
	* 指示了cpu要读取指令的地址
	* 同时修改cs、ip：	jmp 2AE3:3
	* 只修改ip寄存器的值： jmp ax
	* 不能使用：mov cs bx
	
## 3.寄存器（内存访问）

1. ds和[address]
	* 内存地址有段地址和偏移地址组成，ds寄存器指示了内存单元的段地址
	
	* 案例：
		* 读取10000H单元的内容
		```
			mov bx 1000H
			mov ds, bx
			mov al, [0]
		```
		* 向10000H单元写数据
		```
			mov bx, 1000H
			mov ds, bx
			mov [0], al
		```
		
2. 栈		
	* 将内存中的一段内存作为栈，具有特殊的访问方式
	* 8086cpu使用ss、sp寄存器指向栈顶的地址，并提供push、pop指令实现入栈、出栈。
	* 8086cpu提供的入栈、出栈会出现越界的问题

数据段、代码段、栈段

3. mov、add、sub指令
```
mov 寄存器, 数据
mov 寄存器, 寄存器
mov 寄存器, 内存单元
mov 内存单元, 寄存器
mov 段寄存器， 寄存器

add/sub 寄存器, 数据
add/sub 寄存器, 寄存器
add/sub 寄存器, 内存单元
add/sub 内存单元, 寄存器
```

## 5.loop和[bx]指令

1. 段前缀：
	* 将内存中的值传送到寄存器可以显示指定段寄存器，而不是使用默认的ds寄存器，如：
		```
			mov ax, cs:[0]
			;或者
			mov ax, es:[bx]
			;或者
			mov ax, [0] ; 段地址在ds中
		```
		
在汇编程序中，数据不能以字母开头：
```
 mov ax, 0ffffh
 ;不能写成
 mov ax ffffh
```		

## 6.包含多个段的程序

例子：
```
assume cs:code, ds:data, ss:stack 	;声明三个段
data segment ; 数据段
	dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h
data ends
stack segment ; 栈段
	dw 0, 0, 0, 0, 0, 0, 0, 0
		; 使用dw定义8个字型数据，在程序加载的时候将取得8个字的内存空间
		; 存放这8个数字，在后面的程序中，将这段空间当做段使用
stack ends		
code segment ; 代码段
	start:  mov ax, stack
			mov ss, ax
			mov sp, 16 			; 指定栈寄存器ss:sp的值
			
			mov ax, data
			mov ds, ax			; 设置数据段
			
			mov bx, 0
			mov cx, 8
		s:  push ds:[bx]
			add bx, 2
			loop s 			; 入栈
			
			mov bx, 0
			mov cx, 8
		s0: pop ds:[bx]
			add bx, 2
			loop s0 		; 出栈
						
			mov ax,4c00h
			int 21h
code ends
end start ; 程序的入口
```

## 7.更灵活的定位内存地址的方法

1. and和or指令：
	* 按位与、按位或

2. ascii码
	* 占用一个字节，可以使用db定义
	* 大小写转换：大写字母与小写字母的差别是二进制编码的第6位是否1，即：2^5 = 32

3. [bx+idata]
	* 更灵活的定位内存单元，如：mov ax, [bx + 200]
	* 含义：将内存单元的内容送入ax，这个内存单元的偏移地址是bx+idata，段地址ds
	* 数学化描述： (ax) = ((ds)*16 + (bx) + 200);
	* 用处：进行数组的处理
	
4. si和di寄存器
	* si和di和bx功能相近，但si和di不能分成两个8位寄存器来使用，下面几句功能一样
	```
	mov bx, 0
	mov ax, [bx + 123]
	; 和
	mov si, 0
	mov ax, [si + 123]
	;和
	mov di, 0
	mov ax, [di + 123]
	```
	
5. [bx+si]和[bx+di]	
	* [bx+si]和[bx+di]含义一样，如： `mov ax, [bx + si]` 
	* 含义：将内存单元的内容送入ax，这个内存单元的偏移地址是bx+si，段地址ds
	* 数学化描述： (ax) = ((ds)*16 + (bx) + (si));
	* 也可写成： `mov ax, [bx][si]`

6. [bx+si+idata]和[bx+di+idata]
	* 数学化描述： (ax) = ((ds)*16 + (bx) + (si) + idata);
	* 下面写法实现功能一样
	```
		mov ax, [bx + si + 200]
		mov ax, [200 + bx + si]
		mov ax, 200[bx][si]
		mov ax, [bx].200[si]
		mov ax, [bx][si].200
	```

## debug用法：
* r命令，查看、改变cpu寄存器的内容
* d命令，查看内存中的内容
* e命令，改写内存中的内容
* u命令，将内存中的机器指令翻译成汇编指令
* t命令，执行一条机器指令
* a命令，以汇编指令的格式在内存中写入一条机器指令
* g命令，执行到某一行。如：g 0012
* p命令，将循环执行完成，在loop s的时候使用

	int 21h; 使用p命令执行

1. debug和汇编编译器masm对指令的不同处理：
	1.1 在debug中，将ds:0的数据送入ax，使用 `mov ax, [0]`，在汇编源程序中这段指令会被编译成`mov ax, 0`，
		在汇编中要实现这个功能可以使用如下方式：
		```
			mov bx, 0
			mov ax, [bx]
			;或者
			mov ax, ds:[0]
		```
		
	


## 编译、链接

1. 编译命令：masm
	* masm a;
	
链接命名：link
	* link a;




	
	
	
	
	
	
	
	
	

